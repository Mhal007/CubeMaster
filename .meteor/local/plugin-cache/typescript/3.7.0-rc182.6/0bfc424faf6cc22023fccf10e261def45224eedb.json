{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/michal-pc/Dokumenty/CubeMaster/generateSVGs.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx",["flow",{}],"nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}]],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"generateSVGs.ts","filename":"/home/michal-pc/Dokumenty/CubeMaster/generateSVGs.ts","inputSourceMap":{"version":3,"file":"generateSVGs.ts","sourceRoot":"","sources":["generateSVGs.ts"],"names":[],"mappings":"AAAA,4BAA4B;AAC5B,uEAAuE;AACvE,EAAE;AACF,2BAA2B;AAC3B,eAAe;AACf,eAAe;AACf,mBAAmB;AACnB,oBAAoB;AACpB,kBAAkB;AAClB,KAAK;AACL,EAAE;AACF,6CAA6C;AAC7C,oBAAoB;AACpB,yBAAyB;AACzB,KAAK;AACL,EAAE;AACF,kBAAkB;AAClB,qBAAqB;AACrB,mBAAmB;AACnB,KAAK;AACL,EAAE;AACF,+CAA+C;AAC/C,EAAE;AACF,0BAA0B;AAC1B,iDAAiD;AACjD,0BAA0B;AAC1B,8CAA8C;AAC9C,iBAAiB;AACjB,wCAAwC;AACxC,EAAE;AACF,iCAAiC;AACjC,EAAE;AACF,oCAAoC;AACpC,mCAAmC;AACnC,qCAAqC;AACrC,EAAE;AACF,+DAA+D;AAC/D,2CAA2C;AAC3C,0CAA0C;AAC1C,+EAA+E;AAC/E,4EAA4E;AAC5E,+BAA+B;AAC/B,gCAAgC;AAChC,sDAAsD;AACtD,mCAAmC;AACnC,qCAAqC;AACrC,YAAY;AACZ,OAAO;AACP,EAAE;AACF,2DAA2D;AAC3D,yBAAyB;AACzB,oCAAoC;AACpC,QAAQ;AACR,EAAE;AACF,oCAAoC;AACpC,mFAAmF;AACnF,QAAQ;AACR,EAAE;AACF,+EAA+E;AAC/E,OAAO;AACP,EAAE;AACF,qDAAqD;AACrD,mEAAmE;AACnE,iDAAiD;AACjD,mCAAmC;AACnC,+BAA+B;AAC/B,iCAAiC;AACjC,2CAA2C;AAC3C,YAAY;AACZ,YAAY;AACZ,EAAE;AACF,uDAAuD;AACvD,mEAAmE;AACnE,8CAA8C;AAC9C,iDAAiD;AACjD,gCAAgC;AAChC,gCAAgC;AAChC,2CAA2C;AAC3C,YAAY;AACZ,YAAY;AACZ,EAAE;AACF,wDAAwD;AACxD,mEAAmE;AACnE,iDAAiD;AACjD,8CAA8C;AAC9C,+BAA+B;AAC/B,iCAAiC;AACjC,2CAA2C;AAC3C,YAAY;AACZ,YAAY;AACZ,EAAE;AACF,sDAAsD;AACtD,mEAAmE;AACnE,mCAAmC;AACnC,iDAAiD;AACjD,gCAAgC;AAChC,gCAAgC;AAChC,2CAA2C;AAC3C,YAAY;AACZ,YAAY;AACZ,EAAE;AACF,oDAAoD;AACpD,kBAAkB;AAClB,oBAAoB;AACpB,qBAAqB;AACrB,kBAAkB;AAClB,OAAO;AACP,EAAE;AACF,+DAA+D;AAC/D,gBAAgB;AAChB,4BAA4B;AAC5B,6BAA6B;AAC7B,kDAAkD;AAClD,gBAAgB;AAChB,4BAA4B;AAC5B,6BAA6B;AAC7B,kDAAkD;AAClD,EAAE;AACF,uBAAuB;AACvB,OAAO;AACP,EAAE;AACF,iFAAiF;AACjF,EAAE;AACF,6DAA6D;AAC7D,uBAAuB;AACvB,qDAAqD;AACrD,oBAAoB;AACpB,SAAS;AACT,EAAE;AACF,4BAA4B;AAC5B,iFAAiF;AACjF,8DAA8D;AAC9D,EAAE;AACF,8BAA8B;AAC9B,2CAA2C;AAC3C,0CAA0C;AAC1C,SAAS;AACT,EAAE;AACF,+BAA+B;AAC/B,2CAA2C;AAC3C,0CAA0C;AAC1C,SAAS;AACT,EAAE;AACF,qCAAqC;AACrC,qCAAqC;AACrC,mDAAmD;AACnD,qDAAqD;AACrD,EAAE;AACF,eAAe;AACf,yDAAyD;AACzD,6BAA6B;AAC7B,SAAS;AACT,OAAO;AACP,EAAE;AACF,mDAAmD;AACnD,0BAA0B;AAC1B,EAAE;AACF,8CAA8C;AAC9C,qBAAqB;AACrB,4DAA4D;AAC5D,UAAU;AACV,QAAQ;AACR,EAAE;AACF,kEAAkE;AAClE,EAAE;AACF,sBAAsB;AACtB,OAAO;AACP,EAAE;AACF,uEAAuE;AACvE,EAAE;AACF,8BAA8B;AAC9B,qEAAqE;AACrE,EAAE;AACF,8BAA8B;AAC9B,WAAW;AACX,2CAA2C;AAC3C,6BAA6B;AAC7B,8BAA8B;AAC9B,QAAQ;AACR,4BAA4B;AAC5B,cAAc;AACd,+BAA+B;AAC/B,gCAAgC;AAChC,oCAAoC;AACpC,WAAW;AACX,EAAE;AACF,yBAAyB;AACzB,2BAA2B;AAC3B,sBAAsB;AACtB,gBAAgB;AAChB,oBAAoB;AACpB,4BAA4B;AAC5B,wBAAwB;AACxB,oCAAoC;AACpC,oCAAoC;AACpC,4CAA4C;AAC5C,8CAA8C;AAC9C,0CAA0C;AAC1C,qBAAqB;AACrB,kBAAkB;AAClB,gBAAgB;AAChB,wBAAwB;AACxB,YAAY;AACZ,qBAAqB;AACrB,EAAE;AACF,EAAE;AACF,yBAAyB;AACzB,2BAA2B;AAC3B,8BAA8B;AAC9B,wBAAwB;AACxB,6CAA6C;AAC7C,oBAAoB;AACpB,4BAA4B;AAC5B,wBAAwB;AACxB,oCAAoC;AACpC,oCAAoC;AACpC,4CAA4C;AAC5C,8CAA8C;AAC9C,0CAA0C;AAC1C,qBAAqB;AACrB,kBAAkB;AAClB,gBAAgB;AAChB,wBAAwB;AACxB,YAAY;AACZ,qBAAqB;AACrB,EAAE;AACF,uBAAuB;AACvB,8BAA8B;AAC9B,oBAAoB;AACpB,sBAAsB;AACtB,mCAAmC;AACnC,oEAAoE;AACpE,iBAAiB;AACjB,+CAA+C;AAC/C,wBAAwB;AACxB,4BAA4B;AAC5B,6BAA6B;AAC7B,eAAe;AACf,YAAY;AACZ,WAAW;AACX,EAAE;AACF,yBAAyB;AACzB,yBAAyB;AACzB,+BAA+B;AAC/B,6BAA6B;AAC7B,oBAAoB;AACpB,6EAA6E;AAC7E,2BAA2B;AAC3B,6CAA6C;AAC7C,wDAAwD;AACxD,2DAA2D;AAC3D,yBAAyB;AACzB,wBAAwB;AACxB,+BAA+B;AAC/B,gCAAgC;AAChC,6DAA6D;AAC7D,yCAAyC;AACzC,wEAAwE;AACxE,qBAAqB;AACrB,kBAAkB;AAClB,gBAAgB;AAChB,wBAAwB;AACxB,YAAY;AACZ,qBAAqB;AACrB,aAAa;AACb,OAAO;AACP,EAAE;AACF,oBAAoB;AACpB,KAAK;AACL,EAAE;AACF,sBAAsB;AACtB,kBAAkB;AAClB,kBAAkB;AAClB,uBAAuB;AACvB,oBAAoB;AACpB,SAAS;AACT,oCAAoC;AACpC,mEAAmE;AACnE,mBAAmB;AACnB,qBAAqB;AACrB,UAAU;AACV,EAAE;AACF,sDAAsD;AACtD,UAAU;AACV,QAAQ;AACR,KAAK;AACL,EAAE;AACF,oBAAoB;AACpB,wDAAwD;AACxD,qCAAqC;AACrC,sDAAsD;AACtD,iFAAiF;AACjF,4BAA4B;AAC5B,MAAM;AACN,KAAK;AACL,EAAE;AACF,0EAA0E;AAC1E,qCAAqC;AACrC,sDAAsD;AACtD,iFAAiF;AACjF,4BAA4B;AAC5B,MAAM;AACN,KAAK","sourcesContent":["// import * as fs from 'fs';\n// import { algorithm, line, OLLs, PLLs, point } from './server/const';\n//\n// type strikeFormatted = {\n//   x: number;\n//   y: number;\n//   width: number;\n//   height: number;\n//   fill: string;\n// };\n//\n// type squareFormatted = strikeFormatted & {\n//   stroke: string;\n//   strokeWidth: number;\n// };\n//\n// type marker = {\n//   points: point[];\n//   angle: number;\n// };\n//\n// const filesPath: string = '/public/images/';\n//\n// const getSVGcontent = (\n//   { squares, strikes, lines = [] }: algorithm,\n//   squareLength: number,\n//   spacingLength: number = squareLength / 10\n// ): string => {\n//   const cubeSize = squares[0].length;\n//\n//   console.log('lines', lines);\n//\n//   const colorPrimary = '#ffff45';\n//   const colorSecondary = 'gray';\n//   const colorBackground = 'black';\n//\n//   const squaresFormatted: squareFormatted[][] = squares.map(\n//     (row: number[], rowIndex: number) =>\n//       row.map((face, columnIndex) => ({\n//         x: spacingLength * 2 + columnIndex * (squareLength + spacingLength),\n//         y: spacingLength * 2 + rowIndex * (squareLength + spacingLength),\n//         width: squareLength,\n//         height: squareLength,\n//         fill: face ? colorPrimary : colorSecondary,\n//         stroke: colorBackground,\n//         strokeWidth: spacingLength\n//       }))\n//   );\n//\n//   const getStrikePosition = (index: number): number => {\n//     if (index === 0) {\n//       return 0.5 * spacingLength;\n//     }\n//\n//     if (index - 1 === cubeSize) {\n//       return 1.5 * spacingLength + (index - 1) * (spacingLength + squareLength);\n//     }\n//\n//     return spacingLength * 2 + (index - 1) * (spacingLength + squareLength);\n//   };\n//\n//   const strikesTop: strikeFormatted[] = strikes[0]\n//     ? strikes[0].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(strikeIndex + 1),\n//         y: getStrikePosition(0),\n//         width: squareLength,\n//         height: spacingLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesRight: strikeFormatted[] = strikes[1]\n//     ? strikes[1].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(cubeSize + 1),\n//         y: getStrikePosition(strikeIndex + 1),\n//         width: spacingLength,\n//         height: squareLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesBottom: strikeFormatted[] = strikes[2]\n//     ? strikes[2].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(strikeIndex + 1),\n//         y: getStrikePosition(cubeSize + 1),\n//         width: squareLength,\n//         height: spacingLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesLeft: strikeFormatted[] = strikes[3]\n//     ? strikes[3].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(0),\n//         y: getStrikePosition(strikeIndex + 1),\n//         width: spacingLength,\n//         height: squareLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesFormatted: strikeFormatted[][] = [\n//     strikesTop,\n//     strikesRight,\n//     strikesBottom,\n//     strikesLeft\n//   ];\n//\n//   const getCenter = ({ x: squareX, y: squareY }: point) => {\n//     const x =\n//       2 * spacingLength +\n//       0.5 * squareLength +\n//       (spacingLength + squareLength) * squareX;\n//     const y =\n//       2 * spacingLength +\n//       0.5 * squareLength +\n//       (spacingLength + squareLength) * squareY;\n//\n//     return { x, y };\n//   };\n//\n//   const getPoints = (line: line): line => line.map(point => getCenter(point));\n//\n//   const lineToMarker = (pointA: point, pointB: point) => {\n//     const pointC = {\n//       x: pointA.x + Math.abs(pointB.x - pointA.x),\n//       y: pointA.y\n//     };\n//\n//     const rotationAngle =\n//       (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI -\n//       Math.atan2(pointC.y - pointA.y, pointC.x - pointA.x);\n//\n//     const leftBackPoint = {\n//       x: pointB.x - 0.25 * squareLength,\n//       y: pointB.y - 0.25 * squareLength\n//     };\n//\n//     const rightBackPoint = {\n//       x: pointB.x - 0.25 * squareLength,\n//       y: pointB.y + 0.25 * squareLength\n//     };\n//\n//     console.log('pointA', pointA);\n//     console.log('pointB', pointB);\n//     console.log('leftBackPoint', leftBackPoint);\n//     console.log('rightBackPoint', rightBackPoint);\n//\n//     return {\n//       points: [leftBackPoint, pointB, rightBackPoint],\n//       angle: rotationAngle\n//     };\n//   };\n//\n//   const getMarkers = (line: line): marker[] => {\n//     const markers = [];\n//\n//     for (let i = 0; i < line.length; i++) {\n//       if (i > 0) {\n//         markers.push(lineToMarker(line[i - 1], line[i]));\n//       }\n//     }\n//\n//     markers.push(lineToMarker(line[line.length - 1], line[0]));\n//\n//     return markers;\n//   };\n//\n//   const linesFormatted: line[] = lines.map(line => getPoints(line));\n//\n//   const boardSize: number =\n//     spacingLength * 3 + cubeSize * (squareLength + spacingLength);\n//\n//   const content: string = `\n//     <svg\n//       xmlns=\"http://www.w3.org/2000/svg\"\n//       width=\"${boardSize}\"\n//       height=\"${boardSize}\"\n//     >\n//       <!-- BACKGROUND -->\n//       <rect\n//         width=\"${boardSize}\"\n//         height=\"${boardSize}\"\n//         fill=\"${colorBackground}\"\n//       />\n//\n//       <!-- SQUARES -->\n//       ${squaresFormatted\n//         .map(row =>\n//           row\n//             .map(\n//               square => `\n//                 <rect\n//                   x=\"${square.x}\"\n//                   y=\"${square.y}\"\n//                   width=\"${square.width}\"\n//                   height=\"${square.height}\"\n//                   fill=\"${square.fill}\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//\n//\n//       <!-- STRIKES -->\n//       ${strikesFormatted\n//         .map(strikeGroup =>\n//           strikeGroup\n//             .filter(strike => strike.fill)\n//             .map(\n//               strike => `\n//                 <rect\n//                   x=\"${strike.x}\"\n//                   y=\"${strike.y}\"\n//                   width=\"${strike.width}\"\n//                   height=\"${strike.height}\"\n//                   fill=\"${strike.fill}\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//\n//       <!-- LINES -->\n//       ${linesFormatted.map(\n//         line => `\n//           <polyline\n//           points=\"${line.reduce(\n//             (points, point) => `${points} ${point.x},${point.y}`,\n//             ''\n//           ) + ` ${line[0].x},${line[0].y}`}\"\n//           fill=\"none\"\n//           stroke=\"orange\"\n//           stroke-width=\"3\"\n//           />\n//         `\n//       )}\n//\n//       <!-- MARKERS -->\n//       ${linesFormatted\n//         .map((line: line) =>\n//           getMarkers(line)\n//             .map(\n//               ({ points, angle }: { points: point[]; angle: number }) => `\n//                 <polygon\n//                   points=\"${points.reduce(\n//                     (points: string, point: point) =>\n//                       `${points} ${point.x},${point.y}`,\n//                     ''\n//                   )}\"\n//                   fill=\"red\"\n//                   transform=\"\n//                   translate(${points[1].x} ${points[1].y})\n//                   rotate(${angle} 0 0)\n//                   translate(${-1 * points[1].x} ${-1 * points[1].y})\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//     </svg>\n//   `;\n//\n//   return content;\n// };\n//\n// const writeFile = (\n//   path: string,\n//   name: string,\n//   extension: string,\n//   content: string\n// ) => {\n//   return new Promise(resolve => {\n//     fs.writeFile(`${path}${name}${extension}`, content, err => {\n//       if (err) {\n//         throw err;\n//       }\n//\n//       resolve(`File ${name} created successfully`);\n//     });\n//   });\n// };\n//\n// /* write files */\n// OLLs.filter((OLL: algorithm) => OLL.squares).forEach(\n//   async (scramble: algorithm) => {\n//     const content = getSVGcontent(scramble, 25, 3);\n//     const result = await writeFile(filesPath, scramble.name, '.svg', content);\n//     console.info(result);\n//   }\n// );\n//\n// PLLs.filter((PLL: algorithm) => PLL.lines && PLL.lines.length).forEach(\n//   async (scramble: algorithm) => {\n//     const content = getSVGcontent(scramble, 25, 3);\n//     const result = await writeFile(filesPath, scramble.name, '.svg', content);\n//     console.info(result);\n//   }\n// );\n"]},"passPerPreset":false,"envName":"development","cwd":"/home/michal-pc/Dokumenty/CubeMaster","root":"/home/michal-pc/Dokumenty/CubeMaster","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.7.1","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/michal-pc/Dokumenty/CubeMaster/generateSVGs.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"generateSVGs.ts"}},"code":"// import * as fs from 'fs';\n// import { algorithm, line, OLLs, PLLs, point } from './server/const';\n//\n// type strikeFormatted = {\n//   x: number;\n//   y: number;\n//   width: number;\n//   height: number;\n//   fill: string;\n// };\n//\n// type squareFormatted = strikeFormatted & {\n//   stroke: string;\n//   strokeWidth: number;\n// };\n//\n// type marker = {\n//   points: point[];\n//   angle: number;\n// };\n//\n// const filesPath: string = '/public/images/';\n//\n// const getSVGcontent = (\n//   { squares, strikes, lines = [] }: algorithm,\n//   squareLength: number,\n//   spacingLength: number = squareLength / 10\n// ): string => {\n//   const cubeSize = squares[0].length;\n//\n//   console.log('lines', lines);\n//\n//   const colorPrimary = '#ffff45';\n//   const colorSecondary = 'gray';\n//   const colorBackground = 'black';\n//\n//   const squaresFormatted: squareFormatted[][] = squares.map(\n//     (row: number[], rowIndex: number) =>\n//       row.map((face, columnIndex) => ({\n//         x: spacingLength * 2 + columnIndex * (squareLength + spacingLength),\n//         y: spacingLength * 2 + rowIndex * (squareLength + spacingLength),\n//         width: squareLength,\n//         height: squareLength,\n//         fill: face ? colorPrimary : colorSecondary,\n//         stroke: colorBackground,\n//         strokeWidth: spacingLength\n//       }))\n//   );\n//\n//   const getStrikePosition = (index: number): number => {\n//     if (index === 0) {\n//       return 0.5 * spacingLength;\n//     }\n//\n//     if (index - 1 === cubeSize) {\n//       return 1.5 * spacingLength + (index - 1) * (spacingLength + squareLength);\n//     }\n//\n//     return spacingLength * 2 + (index - 1) * (spacingLength + squareLength);\n//   };\n//\n//   const strikesTop: strikeFormatted[] = strikes[0]\n//     ? strikes[0].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(strikeIndex + 1),\n//         y: getStrikePosition(0),\n//         width: squareLength,\n//         height: spacingLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesRight: strikeFormatted[] = strikes[1]\n//     ? strikes[1].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(cubeSize + 1),\n//         y: getStrikePosition(strikeIndex + 1),\n//         width: spacingLength,\n//         height: squareLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesBottom: strikeFormatted[] = strikes[2]\n//     ? strikes[2].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(strikeIndex + 1),\n//         y: getStrikePosition(cubeSize + 1),\n//         width: squareLength,\n//         height: spacingLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesLeft: strikeFormatted[] = strikes[3]\n//     ? strikes[3].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(0),\n//         y: getStrikePosition(strikeIndex + 1),\n//         width: spacingLength,\n//         height: squareLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesFormatted: strikeFormatted[][] = [\n//     strikesTop,\n//     strikesRight,\n//     strikesBottom,\n//     strikesLeft\n//   ];\n//\n//   const getCenter = ({ x: squareX, y: squareY }: point) => {\n//     const x =\n//       2 * spacingLength +\n//       0.5 * squareLength +\n//       (spacingLength + squareLength) * squareX;\n//     const y =\n//       2 * spacingLength +\n//       0.5 * squareLength +\n//       (spacingLength + squareLength) * squareY;\n//\n//     return { x, y };\n//   };\n//\n//   const getPoints = (line: line): line => line.map(point => getCenter(point));\n//\n//   const lineToMarker = (pointA: point, pointB: point) => {\n//     const pointC = {\n//       x: pointA.x + Math.abs(pointB.x - pointA.x),\n//       y: pointA.y\n//     };\n//\n//     const rotationAngle =\n//       (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI -\n//       Math.atan2(pointC.y - pointA.y, pointC.x - pointA.x);\n//\n//     const leftBackPoint = {\n//       x: pointB.x - 0.25 * squareLength,\n//       y: pointB.y - 0.25 * squareLength\n//     };\n//\n//     const rightBackPoint = {\n//       x: pointB.x - 0.25 * squareLength,\n//       y: pointB.y + 0.25 * squareLength\n//     };\n//\n//     console.log('pointA', pointA);\n//     console.log('pointB', pointB);\n//     console.log('leftBackPoint', leftBackPoint);\n//     console.log('rightBackPoint', rightBackPoint);\n//\n//     return {\n//       points: [leftBackPoint, pointB, rightBackPoint],\n//       angle: rotationAngle\n//     };\n//   };\n//\n//   const getMarkers = (line: line): marker[] => {\n//     const markers = [];\n//\n//     for (let i = 0; i < line.length; i++) {\n//       if (i > 0) {\n//         markers.push(lineToMarker(line[i - 1], line[i]));\n//       }\n//     }\n//\n//     markers.push(lineToMarker(line[line.length - 1], line[0]));\n//\n//     return markers;\n//   };\n//\n//   const linesFormatted: line[] = lines.map(line => getPoints(line));\n//\n//   const boardSize: number =\n//     spacingLength * 3 + cubeSize * (squareLength + spacingLength);\n//\n//   const content: string = `\n//     <svg\n//       xmlns=\"http://www.w3.org/2000/svg\"\n//       width=\"${boardSize}\"\n//       height=\"${boardSize}\"\n//     >\n//       <!-- BACKGROUND -->\n//       <rect\n//         width=\"${boardSize}\"\n//         height=\"${boardSize}\"\n//         fill=\"${colorBackground}\"\n//       />\n//\n//       <!-- SQUARES -->\n//       ${squaresFormatted\n//         .map(row =>\n//           row\n//             .map(\n//               square => `\n//                 <rect\n//                   x=\"${square.x}\"\n//                   y=\"${square.y}\"\n//                   width=\"${square.width}\"\n//                   height=\"${square.height}\"\n//                   fill=\"${square.fill}\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//\n//\n//       <!-- STRIKES -->\n//       ${strikesFormatted\n//         .map(strikeGroup =>\n//           strikeGroup\n//             .filter(strike => strike.fill)\n//             .map(\n//               strike => `\n//                 <rect\n//                   x=\"${strike.x}\"\n//                   y=\"${strike.y}\"\n//                   width=\"${strike.width}\"\n//                   height=\"${strike.height}\"\n//                   fill=\"${strike.fill}\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//\n//       <!-- LINES -->\n//       ${linesFormatted.map(\n//         line => `\n//           <polyline\n//           points=\"${line.reduce(\n//             (points, point) => `${points} ${point.x},${point.y}`,\n//             ''\n//           ) + ` ${line[0].x},${line[0].y}`}\"\n//           fill=\"none\"\n//           stroke=\"orange\"\n//           stroke-width=\"3\"\n//           />\n//         `\n//       )}\n//\n//       <!-- MARKERS -->\n//       ${linesFormatted\n//         .map((line: line) =>\n//           getMarkers(line)\n//             .map(\n//               ({ points, angle }: { points: point[]; angle: number }) => `\n//                 <polygon\n//                   points=\"${points.reduce(\n//                     (points: string, point: point) =>\n//                       `${points} ${point.x},${point.y}`,\n//                     ''\n//                   )}\"\n//                   fill=\"red\"\n//                   transform=\"\n//                   translate(${points[1].x} ${points[1].y})\n//                   rotate(${angle} 0 0)\n//                   translate(${-1 * points[1].x} ${-1 * points[1].y})\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//     </svg>\n//   `;\n//\n//   return content;\n// };\n//\n// const writeFile = (\n//   path: string,\n//   name: string,\n//   extension: string,\n//   content: string\n// ) => {\n//   return new Promise(resolve => {\n//     fs.writeFile(`${path}${name}${extension}`, content, err => {\n//       if (err) {\n//         throw err;\n//       }\n//\n//       resolve(`File ${name} created successfully`);\n//     });\n//   });\n// };\n//\n// /* write files */\n// OLLs.filter((OLL: algorithm) => OLL.squares).forEach(\n//   async (scramble: algorithm) => {\n//     const content = getSVGcontent(scramble, 25, 3);\n//     const result = await writeFile(filesPath, scramble.name, '.svg', content);\n//     console.info(result);\n//   }\n// );\n//\n// PLLs.filter((PLL: algorithm) => PLL.lines && PLL.lines.length).forEach(\n//   async (scramble: algorithm) => {\n//     const content = getSVGcontent(scramble, 25, 3);\n//     const result = await writeFile(filesPath, scramble.name, '.svg', content);\n//     console.info(result);\n//   }\n// );","map":{"version":3,"sources":["generateSVGs.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// import * as fs from 'fs';\n// import { algorithm, line, OLLs, PLLs, point } from './server/const';\n//\n// type strikeFormatted = {\n//   x: number;\n//   y: number;\n//   width: number;\n//   height: number;\n//   fill: string;\n// };\n//\n// type squareFormatted = strikeFormatted & {\n//   stroke: string;\n//   strokeWidth: number;\n// };\n//\n// type marker = {\n//   points: point[];\n//   angle: number;\n// };\n//\n// const filesPath: string = '/public/images/';\n//\n// const getSVGcontent = (\n//   { squares, strikes, lines = [] }: algorithm,\n//   squareLength: number,\n//   spacingLength: number = squareLength / 10\n// ): string => {\n//   const cubeSize = squares[0].length;\n//\n//   console.log('lines', lines);\n//\n//   const colorPrimary = '#ffff45';\n//   const colorSecondary = 'gray';\n//   const colorBackground = 'black';\n//\n//   const squaresFormatted: squareFormatted[][] = squares.map(\n//     (row: number[], rowIndex: number) =>\n//       row.map((face, columnIndex) => ({\n//         x: spacingLength * 2 + columnIndex * (squareLength + spacingLength),\n//         y: spacingLength * 2 + rowIndex * (squareLength + spacingLength),\n//         width: squareLength,\n//         height: squareLength,\n//         fill: face ? colorPrimary : colorSecondary,\n//         stroke: colorBackground,\n//         strokeWidth: spacingLength\n//       }))\n//   );\n//\n//   const getStrikePosition = (index: number): number => {\n//     if (index === 0) {\n//       return 0.5 * spacingLength;\n//     }\n//\n//     if (index - 1 === cubeSize) {\n//       return 1.5 * spacingLength + (index - 1) * (spacingLength + squareLength);\n//     }\n//\n//     return spacingLength * 2 + (index - 1) * (spacingLength + squareLength);\n//   };\n//\n//   const strikesTop: strikeFormatted[] = strikes[0]\n//     ? strikes[0].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(strikeIndex + 1),\n//         y: getStrikePosition(0),\n//         width: squareLength,\n//         height: spacingLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesRight: strikeFormatted[] = strikes[1]\n//     ? strikes[1].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(cubeSize + 1),\n//         y: getStrikePosition(strikeIndex + 1),\n//         width: spacingLength,\n//         height: squareLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesBottom: strikeFormatted[] = strikes[2]\n//     ? strikes[2].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(strikeIndex + 1),\n//         y: getStrikePosition(cubeSize + 1),\n//         width: squareLength,\n//         height: spacingLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesLeft: strikeFormatted[] = strikes[3]\n//     ? strikes[3].map((strike: number, strikeIndex: number) => ({\n//         x: getStrikePosition(0),\n//         y: getStrikePosition(strikeIndex + 1),\n//         width: spacingLength,\n//         height: squareLength,\n//         fill: strike ? colorPrimary : ''\n//       }))\n//     : [];\n//\n//   const strikesFormatted: strikeFormatted[][] = [\n//     strikesTop,\n//     strikesRight,\n//     strikesBottom,\n//     strikesLeft\n//   ];\n//\n//   const getCenter = ({ x: squareX, y: squareY }: point) => {\n//     const x =\n//       2 * spacingLength +\n//       0.5 * squareLength +\n//       (spacingLength + squareLength) * squareX;\n//     const y =\n//       2 * spacingLength +\n//       0.5 * squareLength +\n//       (spacingLength + squareLength) * squareY;\n//\n//     return { x, y };\n//   };\n//\n//   const getPoints = (line: line): line => line.map(point => getCenter(point));\n//\n//   const lineToMarker = (pointA: point, pointB: point) => {\n//     const pointC = {\n//       x: pointA.x + Math.abs(pointB.x - pointA.x),\n//       y: pointA.y\n//     };\n//\n//     const rotationAngle =\n//       (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI -\n//       Math.atan2(pointC.y - pointA.y, pointC.x - pointA.x);\n//\n//     const leftBackPoint = {\n//       x: pointB.x - 0.25 * squareLength,\n//       y: pointB.y - 0.25 * squareLength\n//     };\n//\n//     const rightBackPoint = {\n//       x: pointB.x - 0.25 * squareLength,\n//       y: pointB.y + 0.25 * squareLength\n//     };\n//\n//     console.log('pointA', pointA);\n//     console.log('pointB', pointB);\n//     console.log('leftBackPoint', leftBackPoint);\n//     console.log('rightBackPoint', rightBackPoint);\n//\n//     return {\n//       points: [leftBackPoint, pointB, rightBackPoint],\n//       angle: rotationAngle\n//     };\n//   };\n//\n//   const getMarkers = (line: line): marker[] => {\n//     const markers = [];\n//\n//     for (let i = 0; i < line.length; i++) {\n//       if (i > 0) {\n//         markers.push(lineToMarker(line[i - 1], line[i]));\n//       }\n//     }\n//\n//     markers.push(lineToMarker(line[line.length - 1], line[0]));\n//\n//     return markers;\n//   };\n//\n//   const linesFormatted: line[] = lines.map(line => getPoints(line));\n//\n//   const boardSize: number =\n//     spacingLength * 3 + cubeSize * (squareLength + spacingLength);\n//\n//   const content: string = `\n//     <svg\n//       xmlns=\"http://www.w3.org/2000/svg\"\n//       width=\"${boardSize}\"\n//       height=\"${boardSize}\"\n//     >\n//       <!-- BACKGROUND -->\n//       <rect\n//         width=\"${boardSize}\"\n//         height=\"${boardSize}\"\n//         fill=\"${colorBackground}\"\n//       />\n//\n//       <!-- SQUARES -->\n//       ${squaresFormatted\n//         .map(row =>\n//           row\n//             .map(\n//               square => `\n//                 <rect\n//                   x=\"${square.x}\"\n//                   y=\"${square.y}\"\n//                   width=\"${square.width}\"\n//                   height=\"${square.height}\"\n//                   fill=\"${square.fill}\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//\n//\n//       <!-- STRIKES -->\n//       ${strikesFormatted\n//         .map(strikeGroup =>\n//           strikeGroup\n//             .filter(strike => strike.fill)\n//             .map(\n//               strike => `\n//                 <rect\n//                   x=\"${strike.x}\"\n//                   y=\"${strike.y}\"\n//                   width=\"${strike.width}\"\n//                   height=\"${strike.height}\"\n//                   fill=\"${strike.fill}\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//\n//       <!-- LINES -->\n//       ${linesFormatted.map(\n//         line => `\n//           <polyline\n//           points=\"${line.reduce(\n//             (points, point) => `${points} ${point.x},${point.y}`,\n//             ''\n//           ) + ` ${line[0].x},${line[0].y}`}\"\n//           fill=\"none\"\n//           stroke=\"orange\"\n//           stroke-width=\"3\"\n//           />\n//         `\n//       )}\n//\n//       <!-- MARKERS -->\n//       ${linesFormatted\n//         .map((line: line) =>\n//           getMarkers(line)\n//             .map(\n//               ({ points, angle }: { points: point[]; angle: number }) => `\n//                 <polygon\n//                   points=\"${points.reduce(\n//                     (points: string, point: point) =>\n//                       `${points} ${point.x},${point.y}`,\n//                     ''\n//                   )}\"\n//                   fill=\"red\"\n//                   transform=\"\n//                   translate(${points[1].x} ${points[1].y})\n//                   rotate(${angle} 0 0)\n//                   translate(${-1 * points[1].x} ${-1 * points[1].y})\"\n//                 />\n//               `\n//             )\n//             .join('')\n//         )\n//         .join('')}\n//     </svg>\n//   `;\n//\n//   return content;\n// };\n//\n// const writeFile = (\n//   path: string,\n//   name: string,\n//   extension: string,\n//   content: string\n// ) => {\n//   return new Promise(resolve => {\n//     fs.writeFile(`${path}${name}${extension}`, content, err => {\n//       if (err) {\n//         throw err;\n//       }\n//\n//       resolve(`File ${name} created successfully`);\n//     });\n//   });\n// };\n//\n// /* write files */\n// OLLs.filter((OLL: algorithm) => OLL.squares).forEach(\n//   async (scramble: algorithm) => {\n//     const content = getSVGcontent(scramble, 25, 3);\n//     const result = await writeFile(filesPath, scramble.name, '.svg', content);\n//     console.info(result);\n//   }\n// );\n//\n// PLLs.filter((PLL: algorithm) => PLL.lines && PLL.lines.length).forEach(\n//   async (scramble: algorithm) => {\n//     const content = getSVGcontent(scramble, 25, 3);\n//     const result = await writeFile(filesPath, scramble.name, '.svg', content);\n//     console.info(result);\n//   }\n// );\n"],"sourceRoot":""},"sourceType":"module","hash":"0bfc424faf6cc22023fccf10e261def45224eedb"}
